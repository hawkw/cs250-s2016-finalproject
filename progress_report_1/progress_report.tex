\documentclass[a4paper,nobib]{tufte-handout}


\usepackage{url}
\usepackage{setspace}

\usepackage[english]{babel}
\usepackage{csquotes}

\usepackage{hyperref}
\usepackage{cleveref}

\usepackage{graphicx} % allow embedded images
  \setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
  \graphicspath{{../imgs/}} % set of paths to search for images
\usepackage{amsmath}  % extended mathematics
\usepackage{booktabs}
\usepackage{units}    % non-stacked fractions and better unit spacing
\usepackage{multicol} % multiple column layout facilities
\usepackage{minted}
\usepackage{fancyvrb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{placeins}

\setminted{ style=trac
          %, fontfamily = fvm
          , fontsize = \small
          , mathescape = true
        %   , frame = leftline
        %   , framerule = 0.4pt
        %   , framesep = 2mm
          , linenos = true
          , numberblanklines = true
          }
\title{CMPSC250 Final Project Progress Report I}
\author{Aubrey Collins and Hawk Weisman}
\begin{document}

\maketitle

\newthought{We have decided to switch} the subject of our project from finger trees to onion routing. Onion routing is a process by which intermediary nodes in a network do not know the original source, final destination, or contents of the messages they are relaying, allowing for anonymous communication. This works by encapsulating each message in an ``onion'', a data structure characterized by multiple layers of encryption. Each routing node between source and destination decrypts a layer, revealing information about where to send the onion next. It pads the onion back to its original size, so that future nodes cannot estimate how many times the onion has already been forwarded. It then sends the onion to the next node in the path, and the process continues until the message arrives at the destination.

\newthought{In onion routing software} such as TOR, a client typically picks a random path to the destination rather than the shortest path. This feature is intended to increase the security of the network. However, this makes onion routing unusable for applications which require low latency, such as voice chatting. We will simulate an onion-routed network in Scala, with the added goal of reducing latency. To this end, we will use a distributed algorithm to minimize the number of times an onion must be forwarded before arriving at its destination, while still maintaining anonyminity. We will then analyze our network to evaluate the tradeoff between security and latency, along with typical computational complexity analysis.


\newthought{Dijkstra’s algorithm} and other centralized shortest-path algorithms are not ideal for this use case. The first reason for this is security. Dijkstra’s algorithm would require each peer to know every edge in the graph, but this could enable an attacker to make reasonable guesses as to where a particular message is coming from or where it is going. For example, consider the case where a node $A$ is connected to node $B$ and no other nodes. Then it becomes clear that node $A$ is the final destination of any message it receives from $B$, and the originator of any message which it sends to $B$.

Furthermore, Djikstra's algorithm suffers from scalability issues does scale well for this application. In networks with large amounts of peers, each peer would have to devote a large amount of memory to keeping track of the network state, much of which would be irrelevant to the messages it is trying to send or receive.

A distributed implementation could help alleviate these issues so that all nodes are not necessarily aware of the entire network geography. Several distributed shortest-path algorithms have been published, and we are currently exploring these options.
\end{document}
